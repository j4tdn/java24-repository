Inheritance = t/c kế  thừa
Def: 
- Khi có các KDL có chung tt &! method chung
	=> Tạo ra các KDL cha để chứa các phần chung đó để reuse code
	
KDL cha là:
+ class: khi muốn thừa kế các thuộc tính & phương thức có body
+ interface: tạo ra các hàm chung chưa biết phần body
			==> abstract method
+ abstract class: similar class nhưng có thể chứa thêm hàm chung ko có body

Ques 1: Java có hỗ trợ đa thừa kế không?
	-> Đa thừa kế: 1 class con có thể thừa kế N class cha
==> KHÔNG
*Vì: khi class con thừa kế từ class cha, ko bắt buộc phải override hàm từ class cha
nếu trường hợp class cha có chung hàm, chung phần khai báo mà class con lại không 
override, khi lấy Obj con gọi hàm chung đó --> ko biết phải dùng từ ai

Ques 2: Phân biệt abstract class & interface

---> 100% đúng với version JDK 1.0 đến 1.7

- Giống
  + Đóng vai trò là 1 KDL cha
  + Có thể chứa hàm trừu tượng(chỉ chứa phần khai báo, ko có thân hàm)
  + Khi có KDL là class extends, implements từ abstract class/interface
    hoặc tạo ra 1 đối tượng trực tiếp từ abstract class/interface
    --> bắt buộc phải override lại các abstract methods
- Khác
  Abstract class
  + KDL còn là class thừa kế thì dùng từ khóa extends và chỉ được
    phép đơn thừa kế
  + Chứa thêm các hàm "bình thường" (có body)
  + Thuộc tính có thể static hoặc non-static tùy khai báo
  + Hàm bình thường thì có phạm vi trong package hiện tại
  
  Interface
  + KDL còn là class thực thi thì dùng từ khóa implements và có thể
    đơn, đa thực thi
  + Chỉ chứa các hàm trừu tượng
  + Thuộc tính mặc định là "public static final"
  + Hàm trừu tượng trong interface mặc định là public abstract
  
  + Từ Java8 trở đi interface có thêm hàm bình thường: default, static, private 
  
Khái niệm: class, abstract class, interface
- class extends class
- class extends abstract class
- class implements interface
----------------
- interface extends interface
  --> khi có các interface có chung các hàm trừu tượng
      tạo ra interface cha cho các interface con thừa kế
      gộp các hàm trừu tượng từ interface cha vào interface con
      
- abstract class implements interface
  --> biến các hàm trừu tượng trong interface thành
           các hàm trừu tượng trong abstract class
      không bắt buộc phải override
      
      
----- Thay đổi của interface từ JDK 8, 9 -----
Interface bây giờ ngoài hàm trừu tượng ra nó có thể chứa thêm các
hàm "bình thường"(có body) bằng cách là thêm các từ khóa: default, static, private
Trước JDK 8
+ Một interface có 1/N hàm trừu tượng đi chăng nữa thì muốn tạo 1 đối tượng
  từ interface có 2 cách
  1. Tạo implementation class implements từ interface
     --> override các hàm trừu tượng đó
     --> new impl class ra để tạo đối tượng
     --> Square implements Shape
  2. Dùng từ khóa new trực tiếp interface
     --> override các hàm trực tiếp tại lúc new
     --> anonymous inner type(class) 
Từ JDK 8, bổ sung(cho trường hợp interface có duy nhất 1 hàm trừu tượng)
  Ngoài 2 cách được hỗ trợ bởi các versions trước
  JDK 8 hỗ trợ tạo đối tượng cho interface 
    bằng anonymous function(lambda expression)
    
  VD: Shape: void calcS()
      IntTest: boolean test(int number)